<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>docs.autogen API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>docs.autogen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import print_function
from __future__ import unicode_literals

import re
import inspect
import os
import shutil
import six

try:
    import pathlib
except ImportError:
    import pathlib2 as pathlib

import keras
from keras import backend as K
from keras.backend import numpy_backend

from docs.structure import EXCLUDE
from docs.structure import PAGES
from docs.structure import template_np_implementation
from docs.structure import template_hidden_np_implementation

import sys
if sys.version[0] == &#39;2&#39;:
    reload(sys)
    sys.setdefaultencoding(&#39;utf8&#39;)

keras_dir = pathlib.Path(__file__).resolve().parents[1]


def get_function_signature(function, method=True):
    wrapped = getattr(function, &#39;_original_function&#39;, None)
    if wrapped is None:
        signature = inspect.getfullargspec(function)
    else:
        signature = inspect.getfullargspec(wrapped)
    defaults = signature.defaults
    if method:
        args = signature.args[1:]
    else:
        args = signature.args
    if defaults:
        kwargs = zip(args[-len(defaults):], defaults)
        args = args[:-len(defaults)]
    else:
        kwargs = []
    st = &#39;%s.%s(&#39; % (clean_module_name(function.__module__), function.__name__)

    for a in args:
        st += str(a) + &#39;, &#39;
    for a, v in kwargs:
        if isinstance(v, str):
            v = &#39;\&#39;&#39; + v + &#39;\&#39;&#39;
        st += str(a) + &#39;=&#39; + str(v) + &#39;, &#39;
    if kwargs or args:
        signature = st[:-2] + &#39;)&#39;
    else:
        signature = st + &#39;)&#39;
    return post_process_signature(signature)


def get_class_signature(cls):
    try:
        class_signature = get_function_signature(cls.__init__)
        class_signature = class_signature.replace(&#39;__init__&#39;, cls.__name__)
    except (TypeError, AttributeError):
        # in case the class inherits from object and does not
        # define __init__
        class_signature = &#34;{clean_module_name}.{cls_name}()&#34;.format(
            clean_module_name=cls.__module__,
            cls_name=cls.__name__
        )
    return post_process_signature(class_signature)


def post_process_signature(signature):
    parts = re.split(r&#39;\.(?!\d)&#39;, signature)
    if len(parts) &gt;= 4:
        if parts[1] == &#39;layers&#39;:
            signature = &#39;keras.layers.&#39; + &#39;.&#39;.join(parts[3:])
        if parts[1] == &#39;utils&#39;:
            signature = &#39;keras.utils.&#39; + &#39;.&#39;.join(parts[3:])
        if parts[1] == &#39;backend&#39;:
            signature = &#39;keras.backend.&#39; + &#39;.&#39;.join(parts[3:])
    return signature


def clean_module_name(name):
    if name.startswith(&#39;keras_applications&#39;):
        name = name.replace(&#39;keras_applications&#39;, &#39;keras.applications&#39;)
    if name.startswith(&#39;keras_preprocessing&#39;):
        name = name.replace(&#39;keras_preprocessing&#39;, &#39;keras.preprocessing&#39;)
    return name


def class_to_source_link(cls):
    module_name = clean_module_name(cls.__module__)
    path = module_name.replace(&#39;.&#39;, &#39;/&#39;)
    path += &#39;.py&#39;
    line = inspect.getsourcelines(cls)[-1]
    link = (&#39;https://github.com/keras-team/&#39;
            &#39;keras/blob/master/&#39; + path + &#39;#L&#39; + str(line))
    return &#39;[[source]](&#39; + link + &#39;)&#39;


def code_snippet(snippet):
    result = &#39;```python\n&#39;
    result += snippet.encode(&#39;unicode_escape&#39;).decode(&#39;utf8&#39;) + &#39;\n&#39;
    result += &#39;```\n&#39;
    return result


def count_leading_spaces(s):
    ws = re.search(r&#39;\S&#39;, s)
    if ws:
        return ws.start()
    else:
        return 0


def process_list_block(docstring, starting_point, section_end,
                       leading_spaces, marker):
    ending_point = docstring.find(&#39;\n\n&#39;, starting_point)
    block = docstring[starting_point:
                      (ending_point - 1 if ending_point &gt; -1
                       else section_end)]
    # Place marker for later reinjection.
    docstring_slice = docstring[
        starting_point:section_end].replace(block, marker)
    docstring = (docstring[:starting_point] +
                 docstring_slice +
                 docstring[section_end:])
    lines = block.split(&#39;\n&#39;)
    # Remove the computed number of leading white spaces from each line.
    lines = [re.sub(&#39;^&#39; + &#39; &#39; * leading_spaces, &#39;&#39;, line) for line in lines]
    # Usually lines have at least 4 additional leading spaces.
    # These have to be removed, but first the list roots have to be detected.
    top_level_regex = r&#39;^    ([^\s\\\(]+):(.*)&#39;
    top_level_replacement = r&#39;- __\1__:\2&#39;
    lines = [re.sub(top_level_regex, top_level_replacement, line)
             for line in lines]
    # All the other lines get simply the 4 leading space (if present) removed
    lines = [re.sub(r&#39;^    &#39;, &#39;&#39;, line) for line in lines]
    # Fix text lines after lists
    indent = 0
    text_block = False
    for i in range(len(lines)):
        line = lines[i]
        spaces = re.search(r&#39;\S&#39;, line)
        if spaces:
            # If it is a list element
            if line[spaces.start()] == &#39;-&#39;:
                indent = spaces.start() + 1
                if text_block:
                    text_block = False
                    lines[i] = &#39;\n&#39; + line
            elif spaces.start() &lt; indent:
                text_block = True
                indent = spaces.start()
                lines[i] = &#39;\n&#39; + line
        else:
            text_block = False
            indent = 0
    block = &#39;\n&#39;.join(lines)
    return docstring, block


def process_docstring(docstring):
    # First, extract code blocks and process them.
    code_blocks = []
    if &#39;```&#39; in docstring:
        tmp = docstring[:]
        while &#39;```&#39; in tmp:
            tmp = tmp[tmp.find(&#39;```&#39;):]
            index = tmp[3:].find(&#39;```&#39;) + 6
            snippet = tmp[:index]
            # Place marker in docstring for later reinjection.
            docstring = docstring.replace(
                snippet, &#39;$CODE_BLOCK_%d&#39; % len(code_blocks))
            snippet_lines = snippet.split(&#39;\n&#39;)
            # Remove leading spaces.
            num_leading_spaces = snippet_lines[-1].find(&#39;`&#39;)
            snippet_lines = ([snippet_lines[0]] +
                             [line[num_leading_spaces:]
                             for line in snippet_lines[1:]])
            # Most code snippets have 3 or 4 more leading spaces
            # on inner lines, but not all. Remove them.
            inner_lines = snippet_lines[1:-1]
            leading_spaces = None
            for line in inner_lines:
                if not line or line[0] == &#39;\n&#39;:
                    continue
                spaces = count_leading_spaces(line)
                if leading_spaces is None:
                    leading_spaces = spaces
                if spaces &lt; leading_spaces:
                    leading_spaces = spaces
            if leading_spaces:
                snippet_lines = ([snippet_lines[0]] +
                                 [line[leading_spaces:]
                                  for line in snippet_lines[1:-1]] +
                                 [snippet_lines[-1]])
            snippet = &#39;\n&#39;.join(snippet_lines)
            code_blocks.append(snippet)
            tmp = tmp[index:]

    # Format docstring lists.
    section_regex = r&#39;\n( +)# (.*)\n&#39;
    section_idx = re.search(section_regex, docstring)
    shift = 0
    sections = {}
    while section_idx and section_idx.group(2):
        anchor = section_idx.group(2)
        leading_spaces = len(section_idx.group(1))
        shift += section_idx.end()
        next_section_idx = re.search(section_regex, docstring[shift:])
        if next_section_idx is None:
            section_end = -1
        else:
            section_end = shift + next_section_idx.start()
        marker = &#39;$&#39; + anchor.replace(&#39; &#39;, &#39;_&#39;) + &#39;$&#39;
        docstring, content = process_list_block(docstring,
                                                shift,
                                                section_end,
                                                leading_spaces,
                                                marker)
        sections[marker] = content
        # `docstring` has changed, so we can&#39;t use `next_section_idx` anymore
        # we have to recompute it
        section_idx = re.search(section_regex, docstring[shift:])

    # Format docstring section titles.
    docstring = re.sub(r&#39;\n(\s+)# (.*)\n&#39;,
                       r&#39;\n\1__\2__\n\n&#39;,
                       docstring)

    # Strip all remaining leading spaces.
    lines = docstring.split(&#39;\n&#39;)
    docstring = &#39;\n&#39;.join([line.lstrip(&#39; &#39;) for line in lines])

    # Reinject list blocks.
    for marker, content in sections.items():
        docstring = docstring.replace(marker, content)

    # Reinject code blocks.
    for i, code_block in enumerate(code_blocks):
        docstring = docstring.replace(
            &#39;$CODE_BLOCK_%d&#39; % i, code_block)
    return docstring


def add_np_implementation(function, docstring):
    np_implementation = getattr(numpy_backend, function.__name__)
    code = inspect.getsource(np_implementation)
    code_lines = code.split(&#39;\n&#39;)
    for i in range(len(code_lines)):
        if code_lines[i]:
            # if there is something on the line, add 8 spaces.
            code_lines[i] = &#39;        &#39; + code_lines[i]
    code = &#39;\n&#39;.join(code_lines[:-1])

    if len(code_lines) &lt; 10:
        section = template_np_implementation.replace(&#39;{{code}}&#39;, code)
    else:
        section = template_hidden_np_implementation.replace(&#39;{{code}}&#39;, code)
    return docstring.replace(&#39;{{np_implementation}}&#39;, section)


def read_file(path):
    with open(path, encoding=&#39;utf-8&#39;) as f:
        return f.read()


def collect_class_methods(cls, methods):
    if isinstance(methods, (list, tuple)):
        return [getattr(cls, m) if isinstance(m, str) else m for m in methods]
    methods = []
    for _, method in inspect.getmembers(cls, predicate=inspect.isroutine):
        if method.__name__[0] == &#39;_&#39; or method.__name__ in EXCLUDE:
            continue
        methods.append(method)
    return methods


def render_function(function, method=True):
    subblocks = []
    signature = get_function_signature(function, method=method)
    if method:
        signature = signature.replace(
            clean_module_name(function.__module__) + &#39;.&#39;, &#39;&#39;)
    subblocks.append(&#39;### &#39; + function.__name__ + &#39;\n&#39;)
    subblocks.append(code_snippet(signature))
    docstring = function.__doc__
    if docstring:
        if (&#39;backend&#39; in signature and
                &#39;{{np_implementation}}&#39; in docstring):
            docstring = add_np_implementation(function, docstring)
        subblocks.append(process_docstring(docstring))
    return &#39;\n\n&#39;.join(subblocks)


def read_page_data(page_data, type):
    assert type in [&#39;classes&#39;, &#39;functions&#39;, &#39;methods&#39;]
    data = page_data.get(type, [])
    for module in page_data.get(&#39;all_module_{}&#39;.format(type), []):
        module_data = []
        for name in dir(module):
            if name[0] == &#39;_&#39; or name in EXCLUDE:
                continue
            module_member = getattr(module, name)
            if (inspect.isclass(module_member) and type == &#39;classes&#39; or
               inspect.isfunction(module_member) and type == &#39;functions&#39;):
                instance = module_member
                if module.__name__ in instance.__module__:
                    if instance not in module_data:
                        module_data.append(instance)
        module_data.sort(key=lambda x: id(x))
        data += module_data
    return data


def get_module_docstring(filepath):
    &#34;&#34;&#34;Extract the module docstring.

    Also finds the line at which the docstring ends.
    &#34;&#34;&#34;
    co = compile(open(filepath, encoding=&#39;utf-8&#39;).read(), filepath, &#39;exec&#39;)
    if co.co_consts and isinstance(co.co_consts[0], six.string_types):
        docstring = co.co_consts[0]
    else:
        print(&#39;Could not get the docstring from &#39; + filepath)
        docstring = &#39;&#39;
    return docstring, co.co_firstlineno


def copy_examples(examples_dir, destination_dir):
    &#34;&#34;&#34;Copy the examples directory in the documentation.

    Prettify files by extracting the docstrings written in Markdown.
    &#34;&#34;&#34;
    pathlib.Path(destination_dir).mkdir(exist_ok=True)
    for file in os.listdir(examples_dir):
        if not file.endswith(&#39;.py&#39;):
            continue
        module_path = os.path.join(examples_dir, file)
        docstring, starting_line = get_module_docstring(module_path)
        destination_file = os.path.join(destination_dir, file[:-2] + &#39;md&#39;)
        with open(destination_file, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as f_out, \
                open(os.path.join(examples_dir, file),
                     &#39;r+&#39;, encoding=&#39;utf-8&#39;) as f_in:

            f_out.write(docstring + &#39;\n\n&#39;)

            # skip docstring
            for _ in range(starting_line):
                next(f_in)

            f_out.write(&#39;```python\n&#39;)
            # next line might be empty.
            line = next(f_in)
            if line != &#39;\n&#39;:
                f_out.write(line)

            # copy the rest of the file.
            for line in f_in:
                f_out.write(line)
            f_out.write(&#39;```&#39;)


def generate(sources_dir):
    &#34;&#34;&#34;Generates the markdown files for the documentation.

    # Arguments
        sources_dir: Where to put the markdown files.
    &#34;&#34;&#34;
    template_dir = os.path.join(str(keras_dir), &#39;docs&#39;, &#39;templates&#39;)

    if K.backend() != &#39;tensorflow&#39;:
        raise RuntimeError(&#39;The documentation must be built &#39;
                           &#39;with the TensorFlow backend because this &#39;
                           &#39;is the only backend with docstrings.&#39;)

    print(&#39;Cleaning up existing sources directory.&#39;)
    if os.path.exists(sources_dir):
        shutil.rmtree(sources_dir)

    print(&#39;Populating sources directory with templates.&#39;)
    shutil.copytree(template_dir, sources_dir)

    readme = read_file(os.path.join(str(keras_dir), &#39;README.md&#39;))
    index = read_file(os.path.join(template_dir, &#39;index.md&#39;))
    index = index.replace(&#39;{{autogenerated}}&#39;, readme[readme.find(&#39;##&#39;):])
    with open(os.path.join(sources_dir, &#39;index.md&#39;), &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        f.write(index)

    print(&#39;Generating docs for Keras %s.&#39; % keras.__version__)
    for page_data in PAGES:
        classes = read_page_data(page_data, &#39;classes&#39;)

        blocks = []
        for element in classes:
            if not isinstance(element, (list, tuple)):
                element = (element, [])
            cls = element[0]
            subblocks = []
            signature = get_class_signature(cls)
            subblocks.append(&#39;&lt;span style=&#34;float:right;&#34;&gt;&#39; +
                             class_to_source_link(cls) + &#39;&lt;/span&gt;&#39;)
            if element[1]:
                subblocks.append(&#39;## &#39; + cls.__name__ + &#39; class\n&#39;)
            else:
                subblocks.append(&#39;### &#39; + cls.__name__ + &#39;\n&#39;)
            subblocks.append(code_snippet(signature))
            docstring = cls.__doc__
            if docstring:
                subblocks.append(process_docstring(docstring))
            methods = collect_class_methods(cls, element[1])
            if methods:
                subblocks.append(&#39;\n---&#39;)
                subblocks.append(&#39;## &#39; + cls.__name__ + &#39; methods\n&#39;)
                subblocks.append(&#39;\n---\n&#39;.join(
                    [render_function(method, method=True)
                     for method in methods]))
            blocks.append(&#39;\n&#39;.join(subblocks))

        methods = read_page_data(page_data, &#39;methods&#39;)

        for method in methods:
            blocks.append(render_function(method, method=True))

        functions = read_page_data(page_data, &#39;functions&#39;)

        for function in functions:
            blocks.append(render_function(function, method=False))

        if not blocks:
            raise RuntimeError(&#39;Found no content for page &#39; +
                               page_data[&#39;page&#39;])

        mkdown = &#39;\n----\n\n&#39;.join(blocks)
        # Save module page.
        # Either insert content into existing page,
        # or create page otherwise.
        page_name = page_data[&#39;page&#39;]
        path = os.path.join(sources_dir, page_name)
        if os.path.exists(path):
            template = read_file(path)
            if &#39;{{autogenerated}}&#39; not in template:
                raise RuntimeError(&#39;Template found for &#39; + path +
                                   &#39; but missing {{autogenerated}}&#39;
                                   &#39; tag.&#39;)
            mkdown = template.replace(&#39;{{autogenerated}}&#39;, mkdown)
            print(&#39;...inserting autogenerated content into template:&#39;, path)
        else:
            print(&#39;...creating new page with autogenerated content:&#39;, path)
        subdir = os.path.dirname(path)
        if not os.path.exists(subdir):
            os.makedirs(subdir)
        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(mkdown)

    shutil.copyfile(os.path.join(str(keras_dir), &#39;CONTRIBUTING.md&#39;),
                    os.path.join(str(sources_dir), &#39;contributing.md&#39;))
    copy_examples(os.path.join(str(keras_dir), &#39;examples&#39;),
                  os.path.join(str(sources_dir), &#39;examples&#39;))


if __name__ == &#39;__main__&#39;:
    generate(os.path.join(str(keras_dir), &#39;docs&#39;, &#39;sources&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="docs.autogen.add_np_implementation"><code class="name flex">
<span>def <span class="ident">add_np_implementation</span></span>(<span>function, docstring)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_np_implementation(function, docstring):
    np_implementation = getattr(numpy_backend, function.__name__)
    code = inspect.getsource(np_implementation)
    code_lines = code.split(&#39;\n&#39;)
    for i in range(len(code_lines)):
        if code_lines[i]:
            # if there is something on the line, add 8 spaces.
            code_lines[i] = &#39;        &#39; + code_lines[i]
    code = &#39;\n&#39;.join(code_lines[:-1])

    if len(code_lines) &lt; 10:
        section = template_np_implementation.replace(&#39;{{code}}&#39;, code)
    else:
        section = template_hidden_np_implementation.replace(&#39;{{code}}&#39;, code)
    return docstring.replace(&#39;{{np_implementation}}&#39;, section)</code></pre>
</details>
</dd>
<dt id="docs.autogen.class_to_source_link"><code class="name flex">
<span>def <span class="ident">class_to_source_link</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_to_source_link(cls):
    module_name = clean_module_name(cls.__module__)
    path = module_name.replace(&#39;.&#39;, &#39;/&#39;)
    path += &#39;.py&#39;
    line = inspect.getsourcelines(cls)[-1]
    link = (&#39;https://github.com/keras-team/&#39;
            &#39;keras/blob/master/&#39; + path + &#39;#L&#39; + str(line))
    return &#39;[[source]](&#39; + link + &#39;)&#39;</code></pre>
</details>
</dd>
<dt id="docs.autogen.clean_module_name"><code class="name flex">
<span>def <span class="ident">clean_module_name</span></span>(<span>name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_module_name(name):
    if name.startswith(&#39;keras_applications&#39;):
        name = name.replace(&#39;keras_applications&#39;, &#39;keras.applications&#39;)
    if name.startswith(&#39;keras_preprocessing&#39;):
        name = name.replace(&#39;keras_preprocessing&#39;, &#39;keras.preprocessing&#39;)
    return name</code></pre>
</details>
</dd>
<dt id="docs.autogen.code_snippet"><code class="name flex">
<span>def <span class="ident">code_snippet</span></span>(<span>snippet)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_snippet(snippet):
    result = &#39;```python\n&#39;
    result += snippet.encode(&#39;unicode_escape&#39;).decode(&#39;utf8&#39;) + &#39;\n&#39;
    result += &#39;```\n&#39;
    return result</code></pre>
</details>
</dd>
<dt id="docs.autogen.collect_class_methods"><code class="name flex">
<span>def <span class="ident">collect_class_methods</span></span>(<span>cls, methods)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_class_methods(cls, methods):
    if isinstance(methods, (list, tuple)):
        return [getattr(cls, m) if isinstance(m, str) else m for m in methods]
    methods = []
    for _, method in inspect.getmembers(cls, predicate=inspect.isroutine):
        if method.__name__[0] == &#39;_&#39; or method.__name__ in EXCLUDE:
            continue
        methods.append(method)
    return methods</code></pre>
</details>
</dd>
<dt id="docs.autogen.copy_examples"><code class="name flex">
<span>def <span class="ident">copy_examples</span></span>(<span>examples_dir, destination_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy the examples directory in the documentation.</p>
<p>Prettify files by extracting the docstrings written in Markdown.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_examples(examples_dir, destination_dir):
    &#34;&#34;&#34;Copy the examples directory in the documentation.

    Prettify files by extracting the docstrings written in Markdown.
    &#34;&#34;&#34;
    pathlib.Path(destination_dir).mkdir(exist_ok=True)
    for file in os.listdir(examples_dir):
        if not file.endswith(&#39;.py&#39;):
            continue
        module_path = os.path.join(examples_dir, file)
        docstring, starting_line = get_module_docstring(module_path)
        destination_file = os.path.join(destination_dir, file[:-2] + &#39;md&#39;)
        with open(destination_file, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as f_out, \
                open(os.path.join(examples_dir, file),
                     &#39;r+&#39;, encoding=&#39;utf-8&#39;) as f_in:

            f_out.write(docstring + &#39;\n\n&#39;)

            # skip docstring
            for _ in range(starting_line):
                next(f_in)

            f_out.write(&#39;```python\n&#39;)
            # next line might be empty.
            line = next(f_in)
            if line != &#39;\n&#39;:
                f_out.write(line)

            # copy the rest of the file.
            for line in f_in:
                f_out.write(line)
            f_out.write(&#39;```&#39;)</code></pre>
</details>
</dd>
<dt id="docs.autogen.count_leading_spaces"><code class="name flex">
<span>def <span class="ident">count_leading_spaces</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_leading_spaces(s):
    ws = re.search(r&#39;\S&#39;, s)
    if ws:
        return ws.start()
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="docs.autogen.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>sources_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates the markdown files for the documentation.</p>
<h1 id="arguments">Arguments</h1>
<pre><code>sources_dir: Where to put the markdown files.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(sources_dir):
    &#34;&#34;&#34;Generates the markdown files for the documentation.

    # Arguments
        sources_dir: Where to put the markdown files.
    &#34;&#34;&#34;
    template_dir = os.path.join(str(keras_dir), &#39;docs&#39;, &#39;templates&#39;)

    if K.backend() != &#39;tensorflow&#39;:
        raise RuntimeError(&#39;The documentation must be built &#39;
                           &#39;with the TensorFlow backend because this &#39;
                           &#39;is the only backend with docstrings.&#39;)

    print(&#39;Cleaning up existing sources directory.&#39;)
    if os.path.exists(sources_dir):
        shutil.rmtree(sources_dir)

    print(&#39;Populating sources directory with templates.&#39;)
    shutil.copytree(template_dir, sources_dir)

    readme = read_file(os.path.join(str(keras_dir), &#39;README.md&#39;))
    index = read_file(os.path.join(template_dir, &#39;index.md&#39;))
    index = index.replace(&#39;{{autogenerated}}&#39;, readme[readme.find(&#39;##&#39;):])
    with open(os.path.join(sources_dir, &#39;index.md&#39;), &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        f.write(index)

    print(&#39;Generating docs for Keras %s.&#39; % keras.__version__)
    for page_data in PAGES:
        classes = read_page_data(page_data, &#39;classes&#39;)

        blocks = []
        for element in classes:
            if not isinstance(element, (list, tuple)):
                element = (element, [])
            cls = element[0]
            subblocks = []
            signature = get_class_signature(cls)
            subblocks.append(&#39;&lt;span style=&#34;float:right;&#34;&gt;&#39; +
                             class_to_source_link(cls) + &#39;&lt;/span&gt;&#39;)
            if element[1]:
                subblocks.append(&#39;## &#39; + cls.__name__ + &#39; class\n&#39;)
            else:
                subblocks.append(&#39;### &#39; + cls.__name__ + &#39;\n&#39;)
            subblocks.append(code_snippet(signature))
            docstring = cls.__doc__
            if docstring:
                subblocks.append(process_docstring(docstring))
            methods = collect_class_methods(cls, element[1])
            if methods:
                subblocks.append(&#39;\n---&#39;)
                subblocks.append(&#39;## &#39; + cls.__name__ + &#39; methods\n&#39;)
                subblocks.append(&#39;\n---\n&#39;.join(
                    [render_function(method, method=True)
                     for method in methods]))
            blocks.append(&#39;\n&#39;.join(subblocks))

        methods = read_page_data(page_data, &#39;methods&#39;)

        for method in methods:
            blocks.append(render_function(method, method=True))

        functions = read_page_data(page_data, &#39;functions&#39;)

        for function in functions:
            blocks.append(render_function(function, method=False))

        if not blocks:
            raise RuntimeError(&#39;Found no content for page &#39; +
                               page_data[&#39;page&#39;])

        mkdown = &#39;\n----\n\n&#39;.join(blocks)
        # Save module page.
        # Either insert content into existing page,
        # or create page otherwise.
        page_name = page_data[&#39;page&#39;]
        path = os.path.join(sources_dir, page_name)
        if os.path.exists(path):
            template = read_file(path)
            if &#39;{{autogenerated}}&#39; not in template:
                raise RuntimeError(&#39;Template found for &#39; + path +
                                   &#39; but missing {{autogenerated}}&#39;
                                   &#39; tag.&#39;)
            mkdown = template.replace(&#39;{{autogenerated}}&#39;, mkdown)
            print(&#39;...inserting autogenerated content into template:&#39;, path)
        else:
            print(&#39;...creating new page with autogenerated content:&#39;, path)
        subdir = os.path.dirname(path)
        if not os.path.exists(subdir):
            os.makedirs(subdir)
        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(mkdown)

    shutil.copyfile(os.path.join(str(keras_dir), &#39;CONTRIBUTING.md&#39;),
                    os.path.join(str(sources_dir), &#39;contributing.md&#39;))
    copy_examples(os.path.join(str(keras_dir), &#39;examples&#39;),
                  os.path.join(str(sources_dir), &#39;examples&#39;))</code></pre>
</details>
</dd>
<dt id="docs.autogen.get_class_signature"><code class="name flex">
<span>def <span class="ident">get_class_signature</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_signature(cls):
    try:
        class_signature = get_function_signature(cls.__init__)
        class_signature = class_signature.replace(&#39;__init__&#39;, cls.__name__)
    except (TypeError, AttributeError):
        # in case the class inherits from object and does not
        # define __init__
        class_signature = &#34;{clean_module_name}.{cls_name}()&#34;.format(
            clean_module_name=cls.__module__,
            cls_name=cls.__name__
        )
    return post_process_signature(class_signature)</code></pre>
</details>
</dd>
<dt id="docs.autogen.get_function_signature"><code class="name flex">
<span>def <span class="ident">get_function_signature</span></span>(<span>function, method=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_signature(function, method=True):
    wrapped = getattr(function, &#39;_original_function&#39;, None)
    if wrapped is None:
        signature = inspect.getfullargspec(function)
    else:
        signature = inspect.getfullargspec(wrapped)
    defaults = signature.defaults
    if method:
        args = signature.args[1:]
    else:
        args = signature.args
    if defaults:
        kwargs = zip(args[-len(defaults):], defaults)
        args = args[:-len(defaults)]
    else:
        kwargs = []
    st = &#39;%s.%s(&#39; % (clean_module_name(function.__module__), function.__name__)

    for a in args:
        st += str(a) + &#39;, &#39;
    for a, v in kwargs:
        if isinstance(v, str):
            v = &#39;\&#39;&#39; + v + &#39;\&#39;&#39;
        st += str(a) + &#39;=&#39; + str(v) + &#39;, &#39;
    if kwargs or args:
        signature = st[:-2] + &#39;)&#39;
    else:
        signature = st + &#39;)&#39;
    return post_process_signature(signature)</code></pre>
</details>
</dd>
<dt id="docs.autogen.get_module_docstring"><code class="name flex">
<span>def <span class="ident">get_module_docstring</span></span>(<span>filepath)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract the module docstring.</p>
<p>Also finds the line at which the docstring ends.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_module_docstring(filepath):
    &#34;&#34;&#34;Extract the module docstring.

    Also finds the line at which the docstring ends.
    &#34;&#34;&#34;
    co = compile(open(filepath, encoding=&#39;utf-8&#39;).read(), filepath, &#39;exec&#39;)
    if co.co_consts and isinstance(co.co_consts[0], six.string_types):
        docstring = co.co_consts[0]
    else:
        print(&#39;Could not get the docstring from &#39; + filepath)
        docstring = &#39;&#39;
    return docstring, co.co_firstlineno</code></pre>
</details>
</dd>
<dt id="docs.autogen.post_process_signature"><code class="name flex">
<span>def <span class="ident">post_process_signature</span></span>(<span>signature)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_process_signature(signature):
    parts = re.split(r&#39;\.(?!\d)&#39;, signature)
    if len(parts) &gt;= 4:
        if parts[1] == &#39;layers&#39;:
            signature = &#39;keras.layers.&#39; + &#39;.&#39;.join(parts[3:])
        if parts[1] == &#39;utils&#39;:
            signature = &#39;keras.utils.&#39; + &#39;.&#39;.join(parts[3:])
        if parts[1] == &#39;backend&#39;:
            signature = &#39;keras.backend.&#39; + &#39;.&#39;.join(parts[3:])
    return signature</code></pre>
</details>
</dd>
<dt id="docs.autogen.process_docstring"><code class="name flex">
<span>def <span class="ident">process_docstring</span></span>(<span>docstring)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_docstring(docstring):
    # First, extract code blocks and process them.
    code_blocks = []
    if &#39;```&#39; in docstring:
        tmp = docstring[:]
        while &#39;```&#39; in tmp:
            tmp = tmp[tmp.find(&#39;```&#39;):]
            index = tmp[3:].find(&#39;```&#39;) + 6
            snippet = tmp[:index]
            # Place marker in docstring for later reinjection.
            docstring = docstring.replace(
                snippet, &#39;$CODE_BLOCK_%d&#39; % len(code_blocks))
            snippet_lines = snippet.split(&#39;\n&#39;)
            # Remove leading spaces.
            num_leading_spaces = snippet_lines[-1].find(&#39;`&#39;)
            snippet_lines = ([snippet_lines[0]] +
                             [line[num_leading_spaces:]
                             for line in snippet_lines[1:]])
            # Most code snippets have 3 or 4 more leading spaces
            # on inner lines, but not all. Remove them.
            inner_lines = snippet_lines[1:-1]
            leading_spaces = None
            for line in inner_lines:
                if not line or line[0] == &#39;\n&#39;:
                    continue
                spaces = count_leading_spaces(line)
                if leading_spaces is None:
                    leading_spaces = spaces
                if spaces &lt; leading_spaces:
                    leading_spaces = spaces
            if leading_spaces:
                snippet_lines = ([snippet_lines[0]] +
                                 [line[leading_spaces:]
                                  for line in snippet_lines[1:-1]] +
                                 [snippet_lines[-1]])
            snippet = &#39;\n&#39;.join(snippet_lines)
            code_blocks.append(snippet)
            tmp = tmp[index:]

    # Format docstring lists.
    section_regex = r&#39;\n( +)# (.*)\n&#39;
    section_idx = re.search(section_regex, docstring)
    shift = 0
    sections = {}
    while section_idx and section_idx.group(2):
        anchor = section_idx.group(2)
        leading_spaces = len(section_idx.group(1))
        shift += section_idx.end()
        next_section_idx = re.search(section_regex, docstring[shift:])
        if next_section_idx is None:
            section_end = -1
        else:
            section_end = shift + next_section_idx.start()
        marker = &#39;$&#39; + anchor.replace(&#39; &#39;, &#39;_&#39;) + &#39;$&#39;
        docstring, content = process_list_block(docstring,
                                                shift,
                                                section_end,
                                                leading_spaces,
                                                marker)
        sections[marker] = content
        # `docstring` has changed, so we can&#39;t use `next_section_idx` anymore
        # we have to recompute it
        section_idx = re.search(section_regex, docstring[shift:])

    # Format docstring section titles.
    docstring = re.sub(r&#39;\n(\s+)# (.*)\n&#39;,
                       r&#39;\n\1__\2__\n\n&#39;,
                       docstring)

    # Strip all remaining leading spaces.
    lines = docstring.split(&#39;\n&#39;)
    docstring = &#39;\n&#39;.join([line.lstrip(&#39; &#39;) for line in lines])

    # Reinject list blocks.
    for marker, content in sections.items():
        docstring = docstring.replace(marker, content)

    # Reinject code blocks.
    for i, code_block in enumerate(code_blocks):
        docstring = docstring.replace(
            &#39;$CODE_BLOCK_%d&#39; % i, code_block)
    return docstring</code></pre>
</details>
</dd>
<dt id="docs.autogen.process_list_block"><code class="name flex">
<span>def <span class="ident">process_list_block</span></span>(<span>docstring, starting_point, section_end, leading_spaces, marker)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_list_block(docstring, starting_point, section_end,
                       leading_spaces, marker):
    ending_point = docstring.find(&#39;\n\n&#39;, starting_point)
    block = docstring[starting_point:
                      (ending_point - 1 if ending_point &gt; -1
                       else section_end)]
    # Place marker for later reinjection.
    docstring_slice = docstring[
        starting_point:section_end].replace(block, marker)
    docstring = (docstring[:starting_point] +
                 docstring_slice +
                 docstring[section_end:])
    lines = block.split(&#39;\n&#39;)
    # Remove the computed number of leading white spaces from each line.
    lines = [re.sub(&#39;^&#39; + &#39; &#39; * leading_spaces, &#39;&#39;, line) for line in lines]
    # Usually lines have at least 4 additional leading spaces.
    # These have to be removed, but first the list roots have to be detected.
    top_level_regex = r&#39;^    ([^\s\\\(]+):(.*)&#39;
    top_level_replacement = r&#39;- __\1__:\2&#39;
    lines = [re.sub(top_level_regex, top_level_replacement, line)
             for line in lines]
    # All the other lines get simply the 4 leading space (if present) removed
    lines = [re.sub(r&#39;^    &#39;, &#39;&#39;, line) for line in lines]
    # Fix text lines after lists
    indent = 0
    text_block = False
    for i in range(len(lines)):
        line = lines[i]
        spaces = re.search(r&#39;\S&#39;, line)
        if spaces:
            # If it is a list element
            if line[spaces.start()] == &#39;-&#39;:
                indent = spaces.start() + 1
                if text_block:
                    text_block = False
                    lines[i] = &#39;\n&#39; + line
            elif spaces.start() &lt; indent:
                text_block = True
                indent = spaces.start()
                lines[i] = &#39;\n&#39; + line
        else:
            text_block = False
            indent = 0
    block = &#39;\n&#39;.join(lines)
    return docstring, block</code></pre>
</details>
</dd>
<dt id="docs.autogen.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_file(path):
    with open(path, encoding=&#39;utf-8&#39;) as f:
        return f.read()</code></pre>
</details>
</dd>
<dt id="docs.autogen.read_page_data"><code class="name flex">
<span>def <span class="ident">read_page_data</span></span>(<span>page_data, type)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_page_data(page_data, type):
    assert type in [&#39;classes&#39;, &#39;functions&#39;, &#39;methods&#39;]
    data = page_data.get(type, [])
    for module in page_data.get(&#39;all_module_{}&#39;.format(type), []):
        module_data = []
        for name in dir(module):
            if name[0] == &#39;_&#39; or name in EXCLUDE:
                continue
            module_member = getattr(module, name)
            if (inspect.isclass(module_member) and type == &#39;classes&#39; or
               inspect.isfunction(module_member) and type == &#39;functions&#39;):
                instance = module_member
                if module.__name__ in instance.__module__:
                    if instance not in module_data:
                        module_data.append(instance)
        module_data.sort(key=lambda x: id(x))
        data += module_data
    return data</code></pre>
</details>
</dd>
<dt id="docs.autogen.render_function"><code class="name flex">
<span>def <span class="ident">render_function</span></span>(<span>function, method=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_function(function, method=True):
    subblocks = []
    signature = get_function_signature(function, method=method)
    if method:
        signature = signature.replace(
            clean_module_name(function.__module__) + &#39;.&#39;, &#39;&#39;)
    subblocks.append(&#39;### &#39; + function.__name__ + &#39;\n&#39;)
    subblocks.append(code_snippet(signature))
    docstring = function.__doc__
    if docstring:
        if (&#39;backend&#39; in signature and
                &#39;{{np_implementation}}&#39; in docstring):
            docstring = add_np_implementation(function, docstring)
        subblocks.append(process_docstring(docstring))
    return &#39;\n\n&#39;.join(subblocks)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="docs" href="index.html">docs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="docs.autogen.add_np_implementation" href="#docs.autogen.add_np_implementation">add_np_implementation</a></code></li>
<li><code><a title="docs.autogen.class_to_source_link" href="#docs.autogen.class_to_source_link">class_to_source_link</a></code></li>
<li><code><a title="docs.autogen.clean_module_name" href="#docs.autogen.clean_module_name">clean_module_name</a></code></li>
<li><code><a title="docs.autogen.code_snippet" href="#docs.autogen.code_snippet">code_snippet</a></code></li>
<li><code><a title="docs.autogen.collect_class_methods" href="#docs.autogen.collect_class_methods">collect_class_methods</a></code></li>
<li><code><a title="docs.autogen.copy_examples" href="#docs.autogen.copy_examples">copy_examples</a></code></li>
<li><code><a title="docs.autogen.count_leading_spaces" href="#docs.autogen.count_leading_spaces">count_leading_spaces</a></code></li>
<li><code><a title="docs.autogen.generate" href="#docs.autogen.generate">generate</a></code></li>
<li><code><a title="docs.autogen.get_class_signature" href="#docs.autogen.get_class_signature">get_class_signature</a></code></li>
<li><code><a title="docs.autogen.get_function_signature" href="#docs.autogen.get_function_signature">get_function_signature</a></code></li>
<li><code><a title="docs.autogen.get_module_docstring" href="#docs.autogen.get_module_docstring">get_module_docstring</a></code></li>
<li><code><a title="docs.autogen.post_process_signature" href="#docs.autogen.post_process_signature">post_process_signature</a></code></li>
<li><code><a title="docs.autogen.process_docstring" href="#docs.autogen.process_docstring">process_docstring</a></code></li>
<li><code><a title="docs.autogen.process_list_block" href="#docs.autogen.process_list_block">process_list_block</a></code></li>
<li><code><a title="docs.autogen.read_file" href="#docs.autogen.read_file">read_file</a></code></li>
<li><code><a title="docs.autogen.read_page_data" href="#docs.autogen.read_page_data">read_page_data</a></code></li>
<li><code><a title="docs.autogen.render_function" href="#docs.autogen.render_function">render_function</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>